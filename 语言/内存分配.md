# 内存基础



#### 内存分配

##### 1. 栈 (Stack)

- 由编译器自动分配与释放, 存放函数的参数值、局部变量
- 是系统数据结构, 对应的线程/进程是惟一的, 因此高效但不灵活[先进后出, 压栈]
- 空间分为静态分配与动态分配
- 静态分配由编译器完成(Auto)
- 动态分配由alloca函数完成(无需释放, 不推荐使用)

##### 2. 堆 (Heap)

- 由程序员分配与释放
- 是函数内部数据结构, 不唯一, 不同堆内存无法相互操作
- 动态分配, iOS中alloc完成, 灵活方便, 但效率降低[顺序随意]

##### 3. 全局区(静态区)

- 全局变量和静态变量是存储在一起, 初始化的一块区域, 未初始化的放在相邻的另一块区域
- 程序结束后由系统进行释放

##### 4. 常量区

- 存放常量字符串, 程序结束由系统进行释放

##### 5. 代码区

- 存放函数的二进制代码

##### Example

```
int a = 0; // 全局初始化区
char *p1;  // 全局未初始化区

main() {
  int a; // 栈
  char s[] = "ssdd" // 栈
  char *p2; // 栈

  char *p3 = "123456"; // p3: 栈 123456: 常量区

  static int c = 10; // 全局静态初始化区

  p1 = (char*)malloc(10); // 手动分配: 堆
  p2 = (char*)malloc(20); // 手动分配: 堆

  strcpy(p1, "123456"); // 123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。

  // 需要分配内存空间和初始化，使用完后需要release释放 (堆区)
  NSString *hello2 = [[NSString alloc] initWithFormat: @"hello"];
  NSString *hello1 = @"ki"; // 常量内存
}
```



#### 堆栈的区别

##### 1. 申请后的系统响应

 - 栈: 只要栈的剩余空间大于申请的空间, 系统既可提供, 否则over
 - 堆: 操作系统有一个记录空闲地址的链表
 - 申请时, 系统会遍历该链表, 找到第一个空间可用的节点, 并把该节点从空闲链表删除, 同时该节点的空间分配给程序
 - 申请的空间一般会在首地址记录空间的大小, 便于delete操作的空间释放
 - 由于申请的空间一般大于申请, 因此系统会自动把多余的部分放置到空闲链表中

#####  2. 申请大小

 - 栈: 
   - 是向低地址扩展的数据结构, 是一块连续的内存地址(栈顶的地址和栈的最大容量(固定常量)是系统预先规定好的), 因此能从栈获取的空间比较小

 - 堆: 
   - 是向高地址扩展的数据结构,是一块不连续的内存区域, (系统用链表存储空闲空间地址, 自然是不连续的, 而链表的遍历方式是由低地址向高地址)受限于算计系统的有效虚拟内存
   - 由此可见,堆获取的空间比较灵活也比较大


#####  3. 效率

 - 栈: 速率高,程序员不可控
 - 堆: 易产生内存碎片, 方便可控, 指针的存取效率相比栈数组低下

#####  4. 内容

 - 栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
 - 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。



#### iOS内存管理对象

> iOS中,系统使用一个链表来维护所有已分配内存空间; 当app启动时,代码区\常量区\全局区以固定,指向这些区的指针不会出错,但是堆\栈时刻变化,当使用指针指向时,需要判断内存释放与否,防止野指针崩溃.

- 继承NSObject的对象存储在堆需要进行内存管理, 非对象类型(int char float double float)无需
 - 使用引用计数判定回收(RetainCount)
   - 代表对象被引用的次数: 整数 (相当于有多少对象在持有该对象)
   - 初始1, 为0时, 系统自动释放
   - 不在持有该对象是, 发送release消息, RetainCount-1 (release不代表释放)
 - dealloc: 写在最后, 可判定该对象是否被释放
   - ARC下[super dealloc]禁止调用
 - 野指针与空指针
   - 野指针:  未初始化的指针
   - 空指针:  指针为nil(不指向存储空间的指针), 发送消息无响应(no break)
   - 悬空指针: 指针指向一个释放过的对象, 发送消息
     - 报错: EXC_BAD_ACCESS Break
     - 程序崩溃多是此问题导致
 - 规律
   - 谁创建谁release
   - 谁retain谁release
 - 缓存
   - 当系统资源耗尽的时候, NSCache可以自动删减缓存, 用NSDictionary需要自己编写挂钩, 在系统发出 "低内存" 通知时手动删减缓存, 而NSCache会自动删减 "最久未使用对象"
   - NSCache是线程安全的, 而NSDictionary不是
     - 在开发者不编写枷锁代码的前提下,  多个线程可以同时访问NSCache, 对缓存来说线程安全很重要: 因为在某个线程中如果读不到缓存中指定的键, 那么就会下载该键所对应的数据, 如果缓存使用得当, 那么应用程序的响应速度就能提高. 只有那些 "重新计算起来很费劲的" 数据才值得缓存, 比如需要从网络获取或从磁盘读取的数据



#### iOS内存管理方式

- Tagged Pointer
   - 使用后, 指针内存储的数据为Tag+Data,就是直接将数据存储到指针中
 - NONPOINTER_ISA
 - 散列表(引用计数表, 弱引用表, 自旋锁)
     - SideTable



#### const

> 相对于定义常量而言，const要比宏效率高很多，而且宏不做检查，只是代码替换，而const会进行编译检查，const要比宏更安全。所以应尽可能的使用const来代替类对象宏

- 编译阶段处理
- 会执行类型检查(可能有错误提示)
- 只可以定义常量(共享内存空间)

```
#const右边的不能修改
- static const NSString *Coder = @"xxx";
  - 局部常量, 可以修改Coder, *Coder不可修改
- const NSString *Coder = @"xxx";
  - 全局常量, 可以修改Coder, *Coder不可修改
- NSString const *Coder = @"xxx";
  - 可以修改Coder, *Coder不可修改
- NSString * const Coder = @"xxx"。
  - 可以修改*Coder, Coder不可修改
```



##### const + extern

- extern

  - 全局变量：也称之为外部变量, 是在方法外部定义的变量。 它不属于哪个方法, 而是属于整个源程序。
  - 作用域是整个源程序。
  - 如果全局便利和局部变量重名, 则在局部变量作用域内, 全局变量被屏蔽, 不起作用。编程时候尽量不使用全局变量

- Example

  ```
  一份全局变量，多个文件都可以访问
  - .m文件 NSString *const TestConstExtern = @"test.const.extern";
  
  调用方式一:
  - .h文件 extern NSString *const TestConstExtern;
  - 外部import .h文件进行调用TestConstExtern
  
  调用方式二:
  - extern NSString *TestConstExtern;
  - 调用TestConstExtern
  ```

  

##### const + static

- static
  - 静态变量
  - 从面向对象的角度触发, 当需要一个数据对象为整类而非某个对象服务, 同时又力求不破坏类的封装性, 既要求此成员隐藏在类的内部，有要求对外不可见的时候，就可以使用static。
  - 优点:
    - 节省内存。静态变量只存储一处，但供所有对象使用。
    - 它的值是可以更新的。
    - 可提高时间效率。只要某个对象对静态变量更新一次，所有的对象都能访问更新后的值

- Example

  ```
  # 不公开
  - .m文件使用: static const NSTimeInterval kAnimationDuration = 5;
  
  # 公开
  - .h文件定义, 外部import .h文件进行使用
  ```

  

#### define

- 预编译处理
- 不会进行检查
- 可以定义 函数+常量
- 使用大量的宏，每次修改宏都需要重新替换，导致编译时间久

