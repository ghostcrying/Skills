# 属性关键字



```
@property (assign/weak/strong/copy) TypeName type; 
```



#### atomic & nonatomic

- atomic

  - 默认属性(可省略), 原子性，属性安全级别的表示，同一时刻只有一个线程访问，具有资源的独占性，但是效率很低。(仅仅是保证get+set的安全)

    ```
    下面写法等价
    @property (copy) NSString *name; 
    @property (copy, atomic) NSString *name; 
    ```

- nonatomic

  - 非原子性，可以多线程访问，效率高

##### 区别

```
/// 三种方式定义的property又有什么区别呢？
@property   (nonatomic, retain) UITextField *userName;
@property   (atomic, retain)    UITextField *userName;
@property   (retain)            UITextField *userName;

// @property(nonatomic, retain) UITextField *userName;
// Generates roughly
- (UITextField *) userName {
   return userName;
}
- (void) setUserName:(UITextField *)userName_ {
   [userName_ retain];
   [userName release];
   userName = userName_;
}

// @property(retain) UITextField *userName;
// Generates roughly
- (UITextField *) userName {
   UITextField *retval = nil;
   @synchronized(self) {
       retval = [[userName retain] autorelease];
   }
   return retval;
}
- (void) setUserName:(UITextField *)userName_ {
   @synchronized(self) {
       [userName release];
       userName = [userName_ retain];
   }
}
```

###### 分析

> 一、代码中第二种、第三种等价 (省略atomic 的情况下，默认就是atomic)。
>
> 而atomic 和 nonatomic 的区别在于，系统自动生成的getter 和 setter 方法不一样。如果我们自己实现getter/setter方法，那么 atomic/nonatomic/retain/assign/copy等这些关键字只起到提示作用，写不写都是一样的。
>
> 对于atomic 的属性，系统生成的getter/setter会保证get/set操作的完整性，不受其他线程影响。比如，线程A的getter方法运行到一半，线程 B 调用了setter，那么线程A的getter 还是能得到一个正确的，不受setter 影响的值。而nonatomic 就没有这个保证了。所以，nonatomic 的速度要比atomic 快
>
> 不过，atomic 并不能保证线程安全。举例来说，如果线程A调用getter的同时，线程B、线程C都在调用setter，那么线程A get 到的值有三种可能：可能线程A先执行，那么获取到的就是线程B、C set 之前的值；也可能是B线程 set 的值； 也可能是线程 C set 的值。
>
> **保证数据完整性——这个多线程编程的最大挑战之一——往往还需要借助其他手段**

```
Atomic
- 是默认的
- 会保证CPU能在别的线程来访问这个属性之前，先执行完当前流程
- 速度不快，因为要保证操作整体完成
nonatomic
- 不是默认的
- 更快
- 线程不安全
- 如果有两个线程访问同一个属性，会出现无法预料的结果。
```

###### 为什么atomic也不是线程安全的？

> 假设有一个atomic 的属性”name”，如果线程A调用[self setName:@"A"]，线程B 调用[self setName:@"B"]， 线程 C调用[self name]，那么所有这些不同线程上的操作都将一次顺序执行，也就是说，如果一个线程正在执行getter/setter，其他线程就得等待。因此，属性 name 是读写安全的。
>
> 但是，如果有另一个线程D 同时再调[name release]，那可能就会crash，因为release 不受getter/setter 操作的限制。也就是说，这个属性只能说是读/写安全的，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。
>
> 如果name 是 nonatomic的，那么上面的例子中的所有线程A、B、C、D 都可以同时执行，可能导致无法预料的结果。如果是atomic 的，那么 A、B、C会串行，而D还是会并发执行.



#### readOnly

> - 只读, 只生成getter, 也就是说不能修改变量
> - 存在于clean memory中， 一经编译则不可修改。



#### readwrite

> - 默认属性, 可读可写, 生成getter+setter
> - 存在于dirty memory， 运行时动态修改的数据
>
> - rwe
>
>   - class_rw_ext_t
>   - 针对rw的优化, 从rw中拆出平时不常用部分, 减少rw的开销
>
>   - 参考: https://www.jianshu.com/p/9481511370a0



#### strong

> 强引用, 默认引用计数+1



#### weak

> 弱引用, 不会导致引用计数+1, 可以用来避免引用循环

##### 实现

```
- runtime维护了一个weak的hash表， 用于存储指向对象的所有weak指针, 其中key是所指对象的指针, value是weak指针的地址
- initWeak
  - objc_storeWeak
  - 声明新旧散列表SideTable
  - 根据location获取对应的SideTable
  - 对SideTable进行加锁,防止线程冲突
  - 进行线程冲突处理预判断
  - 判断isa是否为空, 否则进行初始化
  - 存在旧值, 则weak_unregister_no_lock清理
  - 存储新值, weak_regist er_no_lock
  - 对新旧散列表解锁, 返回第二参数
- release
  - objc_release
  - dealloc -> objc_rootDealloc -> objc_dispose
  - 最终调用clearDeallocing -> weak_clear_no_lock清除引用信息
```



#### assign

> 声明基本数据类型,仅设置变量,是赋值属性(可以用来修饰delegate,但是必须要进行释放,因此weak更加便利)



#### copy

- NSString、NSArray、NSDictionary等等经常使用copy，因为有对应的可变类型，为确保对象的属性值不会无意变动，需要进行**深拷贝 (内存拷贝+指针拷贝)**，保护封装性
  - 例如：对NSString使用可变赋值时，strong修饰仅仅会导致retainCount+1，而copy会进行深拷贝，这样就会分离新旧字符串，防止外部改变
 - block使用copy，是因为默认的block在栈区，使用的时候需要拷贝到堆区（本质是NSObject对象，编译器默认拷贝）

##### 拷贝

- 非集合对象
  - 不可变对象
    - copy： 指针拷贝（地址不变， 指针变化）
    - mutableCopy： 深拷贝（地址、指针都变化）
  - 可变对象
    - copy与mutableCopy： 都是深拷贝
- 集合对象
  - 不可变对象
    - copy：指针拷贝
    - mutableCopy： 深拷贝，但是元素地址不变（称为：单层浅复制）
  - 可变对象
    - copy与mutableCopy： 都是内容拷贝，但是同样元素地址不改变（单层浅复制）
- 对于自定义NSObject，进行copy、mutableCopy操作需要重写并实现copyWithZone、mutableCopyWithZone方法

##### NSCopying & NSMutableCopying

> OC中，对象要使用Copy与MutableCopy，需要分别实现NSCopying协议和NSMutableCopying协议，以及copyWithZone方法和mutableCopyWithZone方法

```
#import <Foundation/Foundation.h>
@interface Person: NSObject <NSCopying, NSMutableCopying>
@property (nonatomic, copy) NSString * name;
@property (nonatomic, assign) NSInteger age;
@end
#import "Person.h"
@implementation Person
- (instancetype)copyWithZone:(nullable NSZone *)zone {
   Person *tmp = [[[Person class] allocWithZone:zone] init];
   tmp.age = self.age;
   tmp.name = self.name;
   return tmp;
}
- (instancetype)mutableCopyWithZone:(NSZone*)zone {
   Person *tmp = [[Person alloc] init];
   tmp.age = self.age;
   tmp.name = [self.name mutableCopy];
   return tmp;
}
@end
```



#### retain

> ARC之前属性构造器的关键字是retain, copy, assign, strong和weak是ARC带出来的关键字。
> retain现在同strong，就是指针指向值地址，同时进行引用计数加1

````
## retain
释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1
@property(nonatomic, retain) UITextField *userName // 编译时自动生成的代码
@synthesize userName = _userName;
- (UITextField *)userName {
  return _userName;
}

- (void)setUserName:(UITextField *)userName {
  [_userName release];
  _userName = [userName retain];
}
```
## strong
```
@property(nonatomic, strong) UIImage *icon; // nonatomic
//mrc 环境
//implementation
@synthesize icon = _icon;
// set
-(void)setIcon:(UIImage *)icon
{
   // 会进行判定
   if(_icon != icon) {
       [_icon release];
       _icon = [icon retain];
   }
}
// get
-(UIImage *)icon {
   return _icon;
}
````





